题目链接：https://www.nowcoder.com/acm/contest/70/E

题意：有一只乌龟，初始在0的位置向右跑。给定一个字符串指令，指令中只含‘T’和‘F’，F表现前进，T表示转向。给定n，表示可以对指令进行n次改变，要求输出乌龟能到达的最远距离。

分析：典型动态规划问题。状态包括，位置坐标，对于在每个位置都可以选择改变指令和不改变两种选择，且给定了能够改变指令的次数，还有就是能到达的最远距离。记录每一种情况到达的最远距离，需要一个思维数组来表示。

----------------
```
状态定义: dp[i][j][k][d]:表示到第i个指令时，转向次数为j,能否到达距离为k的位置，d表示当前朝向，1表示向右，0表示向左

状态转移方程:
	if(str.charAt(i) == 'F')
	{
		//转向,即F变T,不前进，更新当前k
		if(j > 0)
		{
			dp[i][j][k][0] |= dp[i-1][j-1][k][1];		//按位或，表示能否到达k点
			dp[i][j][k][1] |= dp[i-1][j-1][k][0];
		}
		//不转向,继续前进,更新向右前进的dp[i][j][k+1][1]和向左前进的dp[i][j][k-1][0]
		dp[i][j][k-1][0] |= dp[i-1][j][k][0];			//看第i-1个指令时，因为当前不转向，需要上个字符已经转了j次的情况
		dp[i][j][k+1][1] |= dp[i-1][j][k][1];
	}
	else
	{
		//改变,T变F,前进
		if(j>0)
		{	
			dp[i][j][k-1][0] |= dp[i-1][j-1][k][1];		//看第i-1个指令，转向j-1次，能否到达k位置，(因为这里改向之后会直接前进) ,且朝向相反
			dp[i][j][k+1][1] |= dp[i-1][j-1][k][0];
		}
		// 不改变当前'T'，改变朝向
                dp[i][j][k][1] |= dp[i-1][j][k][0];
                dp[i][j][k][0] |= dp[i-1][j][k][1];
	}
```
